<html>
<canvas id="myCanvas" width="1024" height="768"></canvas>
<br/>
Clouds - Image by rawpixel.com
<br/>
<a target="_blank" href="https://icons8.com/icon/E3jrJhWWAvey/airplane">Airplane</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a>
<a target="_blank" href="https://icons8.com/icon/eVRlPdxRxmNe/medical-box">Medical Box</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a>

<script src="https://cdnjs.cloudflare.com/ajax/libs/engine.io-client/3.4.3/engine.io.min.js"></script>

<script>
  const SCREEN_WIDTH = 1024;
  const SCREEN_HEIGHT = 768;
  const SCREEN_MIDDLE_X = SCREEN_WIDTH / 2;
  const SCREEN_MIDDLE_Y = SCREEN_HEIGHT / 2;

  const urlParams = new URLSearchParams(window.location.search);
  const playerId = urlParams.get('playerId') == null ? Math.floor(Math.random() * 1000000) : urlParams.get('playerId');
  const playerName = urlParams.get('playerName') == null ? 'john doe' : urlParams.get('playerName');

  var gameState = {};
  // TODO: Better way of generating random obstacles within boundaries.
  var obstacles = [];
  for (var i =0 ; i < 15; i++) {
    obstacles.push({xPos: Math.floor(Math.random() * 3000) - 2000, yPos: Math.floor(Math.random() * 1000) - 500});
  }
  var angle = 0;
  var mouseDownTimeout;
  var isGameOver = false;

  const cloud = new Image();
  cloud.src = 'cloud.png';
  const airplaneWhite = new Image(32, 32);
  airplaneWhite.src = 'airplane_white.png';
  const airplaneBlack = new Image(32, 32);
  airplaneBlack.src = 'airplane_black.png';
  const medBox = new Image(32, 32);
  medBox.src = 'med_box.png';

  const socket = eio('ws://localhost:1700', {path: '/engine.io/game'});
  // const socket = eio('wss://y-backend.com:1700', {path: '/engine.io/game'});
  socket.on('open', () => {
    console.log('socket opened');
    socket.send(JSON.stringify({type: 'playerjoin', id: playerId, name: playerName}));
    socket.on('message', (data) => {
      const msg = JSON.parse(data);
      if (msg.type == 'gameInfo') {
        gameState = msg;
      } else if (msg.type == 'gameOver') {
        isGameOver = true;
      }
    });
    socket.on('close', () => { console.log('socket closed') });
    window.addEventListener("mousemove", onMouseMove, false);
    window.addEventListener("mousedown", onMouseDown, false);
    window.addEventListener("mouseup", onMouseUp, false);
  });

  function getMouseEventAngle(inputMouseX, inputMouseY) {
    var rect = myCanvas.getBoundingClientRect();
    mouseX = (inputMouseX - rect.left) - SCREEN_MIDDLE_X;
    mouseY = (inputMouseY - rect.top) - SCREEN_MIDDLE_Y;
    mouseY *= -1;

    if (mouseX == 0 && mouseY < 0) {
      angle = 0;
    } else if (mouseX == 0 && mouseY > 0) {
      angle = 180;
    } else if (!(mouseX == 0 && mouseY == 0)) {
      angle = Math.atan(mouseY / mouseX) * 180 / Math.PI;
      if (mouseX < 0) {
        angle += 180;
      }
    }
    if (angle < 0) {
      angle = 360 + angle;
    }
    return angle;
  }

  function genOnShootFn() {
    return function () {
      socket.send(JSON.stringify({type: 'shootbullet', id: playerId, angle: angle}));
      mouseDownTimeout = setTimeout(genOnShootFn(), 10);
    };
  }

  function onMouseDown(event) {
    if (event.which != 1) {
      // Only handle left click events.
      return;
    }
    const angle = getMouseEventAngle(event.clientX, event.clientY);
    socket.send(JSON.stringify({type: 'shootbullet', id: playerId, angle: angle}));
    mouseDownTimeout = setTimeout(genOnShootFn(), 10);
  }

  function onMouseUp(event) {
    if (mouseDownTimeout) {
      clearTimeout(mouseDownTimeout);
    }
  }

  function onMouseMove(event) {
    const angle = getMouseEventAngle(event.clientX, event.clientY);
    socket.send(JSON.stringify({type: 'updateplayer', id: playerId, angle: angle}));
  }


  function draw() {
    window.requestAnimationFrame(draw);
    var canvas = document.getElementById('myCanvas');
    canvas.style.background = "#87CEFA";
    var ctx = canvas.getContext('2d');

    // Clear screen before redrawing.
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    var myX;
    var myY;

    for (const player of gameState.players) {
      if (player.id == playerId) {
        myX = player.xPos;
        myY = player.yPos;
        break;
      }
    }

    // Draw boundaries.
    drawRect(ctx, gameState.upperXboundary - myX + SCREEN_MIDDLE_X, -10000, 10000, 20000, '#00BFFF');
    drawRect(ctx, gameState.lowerXboundary - myX + SCREEN_MIDDLE_X - 20000, -10000, 20000, 20000, '#00BFFF');
    drawRect(ctx, -10000, gameState.upperYboundary - myY + SCREEN_MIDDLE_Y - 10000, 20000, 10000, '#00BFFF');
    drawRect(ctx, -10000, gameState.lowerYboundary - myY + SCREEN_MIDDLE_Y, 20000, 10000, '#00BFFF');

    for (const obstacle of obstacles) {
      drawCloud(ctx, obstacle.xPos - myX + SCREEN_MIDDLE_X, obstacle.yPos - myY + SCREEN_MIDDLE_Y);
    }

    for (const powerup of gameState.powerups) {
      if (powerup.name == 'medkit') {
        drawImage(ctx, medBox, powerup.xPos - myX + SCREEN_MIDDLE_X, powerup.yPos - myY + SCREEN_MIDDLE_Y, powerup.radius * 1.5, powerup.radius * 1.5);
      }
    }

    for (const player of gameState.players) {
      const airplane = player.id == playerId ? airplaneBlack : airplaneWhite;
      const color = player.id == playerId ? 'green' : 'red';
      drawAirplane(ctx, airplane, player.xPos - myX + SCREEN_MIDDLE_X, player.yPos - myY + SCREEN_MIDDLE_Y, player.angle);
      drawText(ctx, player.xPos - myX + SCREEN_MIDDLE_X, player.yPos - myY + SCREEN_MIDDLE_Y + 30, player.name, 'center', color, font='12px Arial');
      drawHealthBar(ctx, player.xPos - myX + SCREEN_MIDDLE_X, player.yPos - myY + SCREEN_MIDDLE_Y - 10, player.health);
    }

    for (const projectile of gameState.projectiles) {
      drawCircle(ctx, projectile.xPos - myX + SCREEN_MIDDLE_X, projectile.yPos - myY + SCREEN_MIDDLE_Y, 2, 'black');
    }

    if (isGameOver) {
      drawText(ctx, SCREEN_WIDTH / 2, 40, 'Game over. Tough scene.', 'center', 'red');
    }
  }

  function drawAirplane(ctx, image, xCenter, yCenter, angle) {
    ctx.setTransform(1, 0, 0, 1, xCenter, yCenter); // sets scale and origin
    ctx.rotate(-angle * Math.PI / 180);
    ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawImage(ctx, image, xCenter, yCenter, width, height) {
    const imgWidth = width == null ? image.width : width;
    const imgHeight = height == null ? image.height : height;
    ctx.drawImage(image, xCenter - image.width / 2, yCenter - image.height / 2, imgWidth, imgHeight);
  }

  function drawCircle(ctx, x, y, r, color='#b8e015') {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath();
  }

  function drawText(ctx, x, y, text, textAlign='left', color='black', font='30px Arial') {
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = textAlign;
    ctx.fillText(text, x, y);
  }

  function drawHealthBar(ctx, x, y, health) {
    ctx.beginPath();
    ctx.rect(x - 75/2, y - 30, 75, 10);
    ctx.fillStyle = "#ff1100";
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();
    ctx.rect(x - 75/2, y - 30, (health/4)*3, 10);
    ctx.fillStyle = "#11ff00";
    ctx.fill();
    ctx.closePath();
  }

  function drawRect(ctx, x, y, width, height, color='#410765') {
    ctx.beginPath();
    ctx.rect(x,y,width,height);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath();
  }

  function drawCloud(ctx, x, y) {
    ctx.drawImage(cloud, x, y);
  }

  draw();
</script>
</html>
